/**
 * segment - A little JavaScript class (without dependencies) to draw and animate SVG path strokes
 * @version v0.0.4
 * @link https://github.com/lmgonzalves/segment
 * @license MIT
 */

function Segment(e, t, n) {
	this.path = e, this.length = e.getTotalLength(), this.path.style.strokeDashoffset = 2 * this.length, this.begin = "undefined" != typeof t ? this.valueOf(t) : 0, this.end = "undefined" != typeof n ? this.valueOf(n) : this.length, this.timer = null, this.draw(this.begin, this.end)
}
Segment.prototype = {
	draw: function(e, t, n, i) {
		if (n) {
			var s = i && i.hasOwnProperty("delay") ? 1e3 * parseFloat(i.delay) : 0,
				a = i && i.hasOwnProperty("easing") ? i.easing : null,
				h = i && i.hasOwnProperty("callback") ? i.callback : null,
				r = this;
			if (this.stop(), s) return delete i.delay, this.timer = setTimeout(function() {
				r.draw(e, t, n, i)
			}, s), this.timer;
			var l = new Date,
				o = 1e3 / 60,
				f = this.begin,
				u = this.end,
				d = this.valueOf(e),
				g = this.valueOf(t);
			! function p() {
				var e = new Date,
					t = (e - l) / 1e3,
					i = t / parseFloat(n),
					s = i;
				return "function" == typeof a && (s = a(s)), i > 1 ? (r.stop(), s = 1) : r.timer = setTimeout(p, o), r.begin = f + (d - f) * s, r.end = u + (g - u) * s, r.begin < 0 && (r.begin = 0), r.end > r.length && (r.end = r.length), r.begin < r.end ? r.draw(r.begin, r.end) : r.draw(r.begin + (r.end - r.begin), r.end - (r.end - r.begin)), i > 1 && "function" == typeof h ? h.call(r.context) : void 0
			}()
		} else this.path.style.strokeDasharray = this.strokeDasharray(e, t)
	},
	strokeDasharray: function(e, t) {
		return this.begin = this.valueOf(e), this.end = this.valueOf(t), [this.length, this.length + this.begin, this.end - this.begin].join(" ")
	},
	valueOf: function(e) {
		var t = parseFloat(e);
		if (("string" == typeof e || e instanceof String) && ~e.indexOf("%")) {
			var n;~
			e.indexOf("+") ? (n = e.split("+"), t = this.percent(n[0]) + parseFloat(n[1])) : ~e.indexOf("-") ? (n = e.split("-"), t = this.percent(n[0]) - parseFloat(n[1])) : t = this.percent(e)
		}
		return t
	},
	stop: function() {
		clearTimeout(this.timer), this.timer = null
	},
	percent: function(e) {
		return parseFloat(e) / 100 * this.length
	}
};